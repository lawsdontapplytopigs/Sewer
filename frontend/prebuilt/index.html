<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <script src="./elm.js" type="text/javascript"></script>
    <script src="./howler.core.min.js" type="text/javascript"></script>
    <script src="./albums.js" type="text/javascript"></script>
    <link href="./fonts/fonts.css" rel="stylesheet">
    <link href="general.css" rel="stylesheet" type="text/plain">
</head>
<body>
    <div>
        You need to have javascript enabled for this site to render.
    </div>
    <div id="elm-node"></div>
    <script>
        let elm = Elm.Main.init({ 
            node: document.getElementById("elm-node"),
            flags: { 
                width : window.innerWidth,
                height : window.innerHeight,
            }
        });
        window.onresize = () => {
            elm.ports.audioPortFromJS.send({
                type : 4,
                viewportGeometry : {
                    width : window.innerWidth,
                    height : window.innerHeight,
                },
            });
        };

        // unfortunately we have to do this here, since the mdgriffith/elm-ui 
        // library overrides our attributes if we do 
        // "E.htmlAttribute <| Html.Attributes.style "autofill" "email"
        // note: we do NOT want to use the mdgriffith/elm-ui function for creating
        // an email input field, because on invalid email adresses it looks 
        // super ugly. Not the library's fault, but the browser's.
        let email = document.getElementById("emailBox");
        if (email != undefined) {
            email.autofill = "email"
        };

        let Player = ( elmApp, discography ) => {

            let pl = {
                howl : undefined
            };
            pl.discography = discography // list of albums
            pl.albumInd = 0;
            pl.songInd = 0;
            pl.index = 0;
            pl.shouldShuffle = false;
            pl.shouldBePlaying = false;
            pl.shouldRepeat = false;
            // we use this to not allow the user to quickly press "play" 4 times 
            // and have the same song fetched and played twice at the same time
            pl._aRequestHasAlreadyBeenSent = false;
            // NOTE: we don't use this to actually track the amount elapsed in
            // real time of the current song. we only use this for things like
            // seeking in a track before it's been fetched, so when the user
            // clicks "play" we can start from that position
            pl.seekAmount = 0;

            // TODO: instead of just inserting this into the album, make another
            // object with the type and embed the album in there
            elmApp.ports.audioPortFromJS.send({
                type : 1,
                discography : discography,
            });

            pl.fetchSong = () => {
                pl._aRequestHasAlreadyBeenSent = true;
                Howler.unload();
                let song = pl.discography[pl.albumInd].songs[pl.songInd];
                pl.howl = new Howl({
                    src : [ song.src ],
                    onplay : () => {
                        elmApp.ports.audioPortFromJS.send({
                            type : 0,
                            event: "SONG_PLAYING"
                        });
                        pl.sendTimeData();
                        pl.sendSelectedAlbumAndSong();
                    },
                    onload : () => {
                        elmApp.ports.audioPortFromJS.send({
                            type : 0,
                            event: "SONG_LOADED"
                        });
                        pl._aRequestHasAlreadyBeenSent = false;
                        if (pl.shouldBePlaying) {
                            let actualSeekSeconds = ((pl.howl.duration() / 100) * perc);
                            pl.howl.seek(actualSeekSeconds);
                            pl.howl.play();
                        };
                    },
                    onend : () => {
                        elmApp.ports.audioPortFromJS.send({
                            type : 0,
                            event: "SONG_ENDED"
                        });
                        if ((pl.shouldBePlaying) && (pl.songInd < (pl.discography[pl.albumInd].songs.length - 1))) {
                            pl.selectSong(pl.albumInd, pl.songInd + 1);
                        };
                    },
                    // TODO: make this work well. sometimes there's `null`s
                    // in the JSON
                    /* onstop : () => { */
                    /*     pl.shouldBePlaying = false; */
                    /* }, */
                    onpause : () => {
                        elmApp.ports.audioPortFromJS.send({
                            type : 0,
                            event: "SONG_PAUSED"
                        });
                        pl.sendTimeData();
                        pl.sendSelectedAlbumAndSong();
                    },
                    onseek : () => {
                        pl.seekAmount = pl.howl.seek();
                        pl.sendSelectedAlbumAndSong();
                        /* pl.sendTimeData(pl.howl.seek()); */
                    }
                });
            };

            pl.selectAlbum = (ind) => {
                if (ind >= pl.discography.length) {
                    ind = pl.discography.length - 1;
                };
                if (ind < 0) {
                    ind = 0;
                };
                pl.albumInd = ind;
                pl.songInd = 0;
                Howler.unload();
                pl.shouldBePlaying = false;
            };

            // when a user selects a song, we always want to play it
            pl.selectSong = (albumIndex, songIndex) => {
                pl.shouldBePlaying = true;

                if (pl.albumInd === albumIndex && pl.songInd === songIndex) {
                    if (pl.howl) {
                        pl.play();
                    } else {
                        pl.fetchSong();
                    };
                    return
                };

                if (albumIndex >= pl.discography.length) {
                    albumIndex = pl.discography.length - 1;
                };
                if (albumIndex < 0) {
                    albumIndex = 0;
                };
                pl.albumInd = ind;

                if (songIndex >= pl.discography[albumIndex].length) {
                    songIndex = pl.discography[albumIndex].length - 1;
                };
                if (songIndex < 0) {
                    songIndex = 0;
                };
                pl.songInd = songIndex;
                Howler.unload();
                pl.play();
            };

            pl.play = () => {
                pl.shouldBePlaying = true;
                pl.seekAmount = 0;
                if (pl.howl) {
                    pl.howl.play();
                } else {
                    pl.fetchSong();
                };
            };

            pl.togglePlaying = () => {
                if (pl.howl) {
                    if (pl.howl.playing()) {
                        pl.shouldBePlaying = false;
                        pl.howl.pause();
                    } else {
                        pl.shouldBePlaying = true;
                        pl.howl.play();
                    };
                } else {
                    pl.shouldBePlaying = !pl.shouldBePlaying;
                    if (pl._aRequestHasAlreadyBeenSent) {
                        return
                    } else {
                        pl.fetchSong();
                    };
                };
                pl.sendTimeData();
            };

            pl.seek = ( perc ) => {
                pl.seekAmount = perc;
                if (pl.howl) {
                    let actualSeekSeconds = ((pl.howl.duration() / 100) * perc);
                    pl.howl.seek(actualSeekSeconds);
                };
                pl.sendTimeData();
            };

            pl.toggleShuffle = () => {
                pl.shouldShuffle = !pl.shouldShuffle;
            };

            pl.toggleRepeat = () => {
                pl.shouldRepeat = !pl.shouldRepeat;
            };

            pl.pressedNext = () => {
                if (pl.shouldShuffle) {
                    pl.selectSong(Math.floor(Math.random() * pl.discography[pl.albumInd].songs.length));
                };
            };

            pl.pressedPrev = () => {
                if (pl.howl) {
                    if (pl.howl.duration() < 3) {
                        pl.selectSong(pl.albumInd, (pl.songInd - 1));
                    } else {
                        pl.selectSong(pl.albumInd, pl.songInd);
                    };
                };
            };

            pl.volume = (val) => {
                Howler.volume(val);
            };

            pl.sendSelectedAlbumAndSong = () => {
                let song = pl.songs[pl.index];
                elmApp.ports.audioPortFromJS.send({
                    type : 3,
                    selectedAlbum : pl.albumInd,
                    selectedSong : pl.songInd,
                });
            };

            // we want to parameterize the seek amount because sometimes we don't
            // want to send the seek amount of the howl instance (because there 
            // isn't one. we want to send the seek amount that WE stored so it'll
            // be displayed properly in the media player. this way the user can 
            // seek into a song before it's even loaded
            // TODO: I just realized: we can't do it unless we send some duration 
            // and also some "isPlaying" state. so i'll have to somehow do that 

            pl.sendTimeData = () => {
                if (pl.howl) {
                    elmApp.ports.audioPortFromJS.send({
                        type : 2,
                        elapsed : Math.floor(pl.howl.seek()),
                        duration : pl.howl.duration(),
                        isPlaying : pl.howl.playing(),
                    });
                };
            };
            // For some reason this causes a cyclic object value type error
            setInterval(() => {
                if (pl.howl) {
                    pl.sendTimeData();
                };
            }, 1000);

            return pl;
        };

        let player = Player(elm, window.SewerslvtAlbums);
        elm.ports.audioPortToJS.subscribe((msg) => {
            console.log(msg);
            if (msg === "TOGGLE_PLAY") {
                console.log("should toggle play");
                player.togglePlaying();
            } else if (msg === "NEXT") {
                player.pressedNext();
            } else if (msg === "PREV") {
                player.pressedPrev();
            } else if (msg === "TOGGLE_SHUFFLE") {
                player.toggleShuffle();
            } else if (msg === "TOGGLE_REPEAT") {
                player.toggleRepeat();
            // i shouldn't be doing this, but it'll get the job done
            } else if (msg.seek !== undefined){
                console.log("should seek");
                player.seek(msg.seek);
            } else if (msg.albumIndex !== undefined) {
                player.selectSong(msg.albumIndex, msg.songIndex);
            } else if (msg.onlyAlbumIndex) {
                player.selectAlbum(msg.onlyAlbumIndex);
            } else {
                console.log("something didn't go as planned...")
                console.log(msg);
            };
        });
        </script>
</body>
<link href="./fonts/pleaseWork.css" rel="stylesheet" type="text/css">
</html>
